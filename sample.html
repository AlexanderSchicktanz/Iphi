<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 3D Text Example</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script src="three.min.js"></script>
    <script src="gsap.js"></script>
    <script src="scenes.js"></script>
    <script>
        let scene, camera, renderer, cube;
        let raycaster, pointer;
        let showingText = false;
        let cards = [];
        let toggle = false;

        init();
        animate();

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Cube
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            cube = new THREE.Mesh(geometry, material);
            scene.add(cube);
            cube.scale.set(0.5, 0.5, 0.5); // Set scale uniformly

            // Raycaster and pointer
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();

            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onPointerMove);
            document.addEventListener('click', onClick);

            // Create text sprites
            createTextSprites();
        }

        function createTextSprites() {
            const texts = [
                { title: "Zitat", content: "Denn die Wahrheit, die so manchen schmerzt, sie führt zuletzt den freien Geist zur Klarheit." },
                { title: "Lebensmotto", content: "Die Wahrheit ist mein Wegweiser, und Menschlichkeit mein Ziel." },
                { title: "Eigenschaft", content: "Edel und tugendhaft\nMitfühlend und empathisch\nMoralisch und aufrichtig\nFriedliebend und versöhnlich\nWillensstark und standhaft" },
                { title: "Sozialer Hintergrund", content: "Tochter des Königs Agamemnon und der Königin Klytämnestra von Mykene\nPriesterin der Göttin Diana (Artemis) auf Tauris\nAdelige Abstammung, aber durch ihre Situation in Tauris in einer Position der Fremdheit und Isolation\nStark geprägt von der griechischen Kultur und ihren familiären Werten" }
            ];

            texts.forEach((text, index) => {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                const scaleFactor = 3; // Increase resolution

                canvas.width = window.screen.width;
                canvas.height = window.screen.height;

                context.strokeStyle = "#F19ED2";
                context.lineWidth = 40;
                context.fillStyle = "#E8C5E5";
                context.beginPath();
                context.roundRect(60, 60, canvas.width - 120, canvas.height - 120, [80]);
                context.stroke();
                context.fill();

                context.fillStyle = 'black';
                context.font = `${30 * scaleFactor}px Arial`;
                context.fillText(text.title, 25 * scaleFactor, 60 * scaleFactor);

                context.font = `${20 * scaleFactor}px Arial`;
                wrapText(context, text.content, 25 * scaleFactor, 110 * scaleFactor, 400 * scaleFactor, 30 * scaleFactor);

                const texture = new THREE.CanvasTexture(canvas);
                texture.minFilter = THREE.LinearFilter;
                texture.magFilter = THREE.LinearFilter; // Ensure linear filter to prevent blurriness
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);

                sprite.scale.set(6, 3, 1); // Adjust scale to fit content
                sprite.position.set(0, index * -3, -1);
                sprite.visible = false;

                scene.add(sprite);
                cards.push(sprite);
            });
        }

        function wrapText(context, text, x, y, maxWidth, lineHeight) {
            const paragraphs = text.split('\n');
            paragraphs.forEach(paragraph => {
                const words = paragraph.split(' ');
                let line = '';
                for (let n = 0; n < words.length; n++) {
                    let testLine = line + words[n] + ' ';
                    let metrics = context.measureText(testLine);
                    let testWidth = metrics.width;
                    if (testWidth > maxWidth && n > 0) {
                        context.fillText(line, x, y);
                        line = words[n] + ' ';
                        y += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                context.fillText(line, x, y);
                y += lineHeight;
            });
        }

        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
        }

        function onClick() {
            if(!document.fullscreenElement){let elem = document.documentElement;

elem
  .requestFullscreen({ navigationUI: "show" })
  .then(() => {})
  .catch((err) => {
    alert(
      `An error occurred while trying to switch into fullscreen mode: ${err.message} (${err.name})`,
    );
  });}
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(scene.children, false);

            if (intersects.length > 0 && intersects[0].object === cube) {
                gsap.to(cube.scale, { duration: 1, x: toggle?.5:2, repeat: 0, ease: "linear" });
                toggle=!toggle;
                showingText = !showingText;
                cards.forEach(sprite => {
                    sprite.visible = showingText;
                });
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            cube.rotation.x += 0.01;
            cube.rotation.y += 0.01;
            if (showingText) {
                for (let i = 0; i < cards.length; i++) {
                    cards[i].position.y += 0.01;
                    if(cards[i].position.y>window.height*3/4){
                        
                    }
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
